#!/bin/sh

WARNING_NO_MAIL_FILE="warning: could not find mail file after create event. Possibly newly downloaded mail that has been read already. Ignoring."

print_usage() {
    echo 'Usage: mailnotify [OPTION]... [DIR_TO_WATCH]

    Options:
      -e, --exclude-dir       Directory to exclude from watching. Mail files
                              created in this directory will not trigger a
                              notification. May be applied multiple times for
                              multiple directories.
    '
}

malformed_args() {
    echo "$0: error: malformed arguments." >&2; echo
    print_usage
}

datetime_formatted() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')]"
}

# Extract option arguments
while [ $# -gt 0 ]; do
    case $1 in
        -e|--exclude-dir)
            EXCLUDE_INPUT="$EXCLUDE_INPUT $(printf "'%s'" "$2")"
            shift
        ;;

        -h|--help)
            print_usage
            exit
        ;;

        *)
            break
    esac
    [ $# -gt 0 ] && shift # shift only if more parameters exist
done

if ! [ $# -eq 1 ] || echo "$1" | grep '^-'; then
    # Error if there is not exactly one parameter or if it starts with "-"
    malformed_args
    exit 1
fi

LISTEN_DIR="$1"

echo "$(datetime_formatted) Listening for new email files in $LISTEN_DIR"; echo

if ! test -z "$EXCLUDE_INPUT" ; then
    echo 'Excluding subdirectories:'
    echo "$EXCLUDE_INPUT"; echo;
    EXCLUDE_INPUT="$(echo "$EXCLUDE_INPUT" | # escape typical characters 
        sed 's/\(\[\|\]\|(\|)\|\\\|\^\|\$\|\.\||\|\?\|*\|+\)/\\\1/g')"

    # Store given dir names to exclude in positional parameter array
    eval "set -- "$EXCLUDE_INPUT""

    # Format exclude pattern out of given dir names to exclude
    EXCLUDE="$(printf '%s)|(' "$@")"
    EXCLUDE="$(echo "${EXCLUDE%?}" |
        sed 's/^/(/g; s/\()|\)/\/.*\1/g')"
fi

EXCLUDE_ROOT="$(echo "$LISTEN_DIR" |
    awk -F '/' '{ gsub("\\.", "\\.", $3); print $3 }')"

inotifywait -mrq -e create \
    --exclude "/$EXCLUDE_ROOT/.*/($EXCLUDE(\.|new|cur))" \
    --format '%w%f' "$LISTEN_DIR" | while read LINE
do
    echo "$(datetime_formatted) $LINE"; echo

    # Check in both `tmp` and `new`. In most cases, mail should be in `new`
    if test -f "$LINE"; then
        MAIL_PATH="$LINE"
    else 
        MAIL_PATH="$(echo "$LINE" | sed 's/tmp/new/g')" 
    fi

    if ! test -f "$MAIL_PATH"; then
        echo "$WARNING_NO_MAIL_FILE"
        continue
    fi

    parsemail "$MAIL_PATH" |
        while IFS="$(printf '\t')" read -r TO FROM SUBJECT PRIORITY; do
            notify-newmail "$TO" "$FROM" "$SUBJECT" "${PRIORITY:-3}"
        done
done

