#!/bin/sh

print_usage() {
    echo 'Usage: mailnotify [OPTION]... [DIR_TO_WATCH]

    Options:
      -e, --exclude-dir       Directory to exclude from watching. Mail files
                              created in this directory will not trigger a
                              notification. May be applied multiple times for
                              multiple directories.
    '
}

malformed_args() {
    echo "$0: error: malformed arguments." >&2; echo
    print_usage
}

datetime_formatted() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')]"
}

# Extract option arguments
while [ $# -gt 0 ]; do
    case $1 in
        -e|--exclude-dir)
            EXCLUDE_INPUT="$EXCLUDE_INPUT $(printf "'%s'" "$2")"
            shift
        ;;

        -h|--help)
            print_usage
            exit
        ;;

        *)
            break
    esac
    [ $# -gt 0 ] && shift # Shift only if more parameters exist
done

if ! [ $# -eq 1 ] || echo "$1" | grep -q '^-'; then
    # Error if there is not exactly one parameter or if it starts with "-"
    malformed_args
    exit 1
fi

mkdir -p $HOME/.cache/mailnotify

LISTEN_DIR="$1"

echo "$(datetime_formatted) Listening for new email files in $LISTEN_DIR"; echo

if ! test -z "$EXCLUDE_INPUT" ; then
    echo 'Excluding subdirectories:'
    echo "$EXCLUDE_INPUT"; echo;
    EXCLUDE_INPUT="$(echo "$EXCLUDE_INPUT" | # escape typical characters 
        sed 's/\(\[\|\]\|(\|)\|\\\|\^\|\$\|\.\||\|\?\|*\|+\)/\\\1/g')"

    # Store given excludeable dir names in positional parameter array
    eval "set -- "$EXCLUDE_INPUT""

    # Format exclude pattern out of given excludeable dir names
    EXCLUDE="$(printf '%s)|(' "$@")"
    EXCLUDE="$(echo "${EXCLUDE%?}" |
        sed 's/^/(/g; s/\()|\)/\/.*\1/g')"
fi

EXCLUDE_ROOT="$(echo "$LISTEN_DIR" |
    awk -F '/' '{ gsub("\\.", "\\.", $3); print $3 }')"

inotifywait -mrq -e create \
    --exclude "/$EXCLUDE_ROOT/.*/($EXCLUDE(\.|new|cur)|(.*,S(\w|$)))" \
    --format '%w%f %f' "$LISTEN_DIR" | while read LINE FILE
do
    echo "$(datetime_formatted) $LINE"; echo

    # Check in both `tmp` and `new` to work around race condition.
    TMP_PATH="$HOME/.cache/$FILE"
    if test -f "$LINE"; then
        cp "$LINE" "$TMP_PATH"
    else 
        cp "$(echo "$LINE" | sed 's/tmp/new/g')" "$TMP_PATH"
    fi

    if ! test -f "$TMP_PATH"; then
        echo "Error: lost track of file unexpectedly: $TMP_PATH" >&2
        continue
    fi

    parsemail "$TMP_PATH" |
        while IFS="$(printf '\t')" read -r TO FROM SUBJECT PRIORITY; do
            notify-newmail "$TO" "$FROM" "$SUBJECT" "${PRIORITY:-3}"
        done

    rm $TMP_PATH
done

